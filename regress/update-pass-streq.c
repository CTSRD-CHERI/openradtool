/*
 * WARNING: automatically generated by ort-c-source 0.8.0.
 * DO NOT EDIT!
 */
#include <sys/queue.h>

#include <assert.h>
#include <stdio.h>
#include <stdint.h> /* int64_t */
#include <stdlib.h>
#include <string.h>
#include <time.h> /* _XOPEN_SOURCE and gmtime_r()*/
#include <unistd.h>

#include <sqlbox.h>

#include "db.h"

/*
 * All SQL statements we'll later define in "stmts".
 */
enum	stmt {
	STMT_FOO_UPDATE_0,
	STMT__MAX
};

/*
 * Definition of our opaque "ort", which contains role information.
 */
struct	ort {
	/* Hidden database connection */
	struct sqlbox *db;
};

/*
 * Define our table columns.
 * Since we're using roles, this is all internal to the source and not 
 * exported.
 */
#define DB_SCHEMA_FOO(_x) \
	#_x ".bar"

/*
 * Our full set of SQL statements.
 * We define these beforehand because that's how sqlbox(3) handles 
 * statement generation.
 * Notice the "AS" part: this allows for multiple inner joins without 
 * ambiguity.
 */
static	const char *const stmts[STMT__MAX] = {
	/* STMT_FOO_UPDATE_0 */
	"UPDATE foo SET bar = ? WHERE bar = ?",
};

/*
 * Finally, all of the functions we'll use.
 */

void
db_trans_open(struct ort *ctx, size_t id, int mode)
{
	struct sqlbox *db = ctx->db;
	int c;

	if (mode < 0)
		c = sqlbox_trans_exclusive(db, 0, id);
	else if (mode > 0)
		c = sqlbox_trans_immediate(db, 0, id);
	else
		c = sqlbox_trans_deferred(db, 0, id);
	if (!c)
		exit(EXIT_FAILURE);
}

void
db_trans_rollback(struct ort *ctx, size_t id)
{
	struct sqlbox *db = ctx->db;

	if (!sqlbox_trans_rollback(db, 0, id))
		exit(EXIT_FAILURE);
}

void
db_trans_commit(struct ort *ctx, size_t id)
{
	struct sqlbox *db = ctx->db;

	if (!sqlbox_trans_commit(db, 0, id))
		exit(EXIT_FAILURE);
}

void
db_logging_data(struct ort *ort, const void *arg, size_t sz)
{

	if (!sqlbox_msg_set_dat(ort->db, arg, sz))
		exit(EXIT_FAILURE);
}

struct ort *
db_open(const char *file)
{

	return db_open_logging(file, NULL, NULL, NULL);
}

struct ort *
db_open_logging(const char *file,
	void (*log)(const char *, void *),
	void (*log_short)(const char *, ...), void *log_arg)
{
	size_t i;
	struct ort *ctx = NULL;
	struct sqlbox_cfg cfg;
	struct sqlbox *db = NULL;
	struct sqlbox_pstmt pstmts[STMT__MAX];
	struct sqlbox_src srcs[1] = {
		{ .fname = (char *)file,
		  .mode = SQLBOX_SRC_RW }
	};

	memset(&cfg, 0, sizeof(struct sqlbox_cfg));
	cfg.msg.func = log;
	cfg.msg.func_short = log_short;
	cfg.msg.dat = log_arg;
	cfg.srcs.srcs = srcs;
	cfg.srcs.srcsz = 1;
	cfg.stmts.stmts = pstmts;
	cfg.stmts.stmtsz = STMT__MAX;

	for (i = 0; i < STMT__MAX; i++)
		pstmts[i].stmt = (char *)stmts[i];

	ctx = malloc(sizeof(struct ort));
	if (ctx == NULL)
		goto err;

	if ((db = sqlbox_alloc(&cfg)) == NULL)
		goto err;
	ctx->db = db;

	/*
	 * Now actually open the database.
	 * If this succeeds, then we're good to go.
	 */

	if (sqlbox_open_async(db, 0))
		return ctx;
err:
	sqlbox_free(db);
	free(ctx);
	return NULL;
}

void
db_close(struct ort *p)
{
	if (p == NULL)
		return;
	sqlbox_free(p->db);
	free(p);
}

/*
 * Fill in a foo from an open statement "stmt".
 * This starts grabbing results from "pos", which may be NULL to start 
 * from zero.
 * This follows DB_SCHEMA_FOO's order for columns.
 */
static void
db_foo_fill(struct ort *ctx, struct foo *p, const struct sqlbox_parmset *set, size_t *pos)
{
	size_t i = 0;

	if (pos == NULL)
		pos = &i;
	memset(p, 0, sizeof(*p));
	if (sqlbox_parm_string_alloc
	    (&set->ps[(*pos)++], &p->bar, NULL) == -1)
		exit(EXIT_FAILURE);
}

static void
db_foo_fill_r(struct ort *ctx, struct foo *p,
	const struct sqlbox_parmset *res, size_t *pos)
{
	size_t i = 0;

	if (pos == NULL)
		pos = &i;
	db_foo_fill(ctx, p, res, pos);
}

/*
 * Free resources from "p" and all nested objects.
 * Does not free the "p" pointer itself.
 * Has no effect if "p" is NULL.
 */
static void
db_foo_unfill(struct foo *p)
{
	if (p == NULL)
		return;
	free(p->bar);
}

static void
db_foo_unfill_r(struct foo *p)
{
	if (p == NULL)
		return;
	db_foo_unfill(p);
}

void
db_foo_free(struct foo *p)
{
	db_foo_unfill_r(p);
	free(p);
}

int
db_foo_update_by_bar_streq(struct ort *ctx, const char *v1, const char *v2)
{
	enum sqlbox_code c;
	struct sqlbox *db = ctx->db;
	struct sqlbox_parm parms[2];
	char hash1[64];

	crypt_newhash(v1, "blowfish,a", hash1, sizeof(hash1));

	memset(parms, 0, sizeof(parms));
	parms[0].sparm = hash1;
	parms[0].type = SQLBOX_PARM_STRING;
	parms[1].sparm = v2;
	parms[1].type = SQLBOX_PARM_STRING;

	c = sqlbox_exec
		(db, 0, STMT_FOO_UPDATE_0,
		 2, parms, SQLBOX_STMT_CONSTRAINT);
	if (c == SQLBOX_CODE_ERROR)
		exit(EXIT_FAILURE);
	return (c == SQLBOX_CODE_OK) ? 1 : 0;
}

